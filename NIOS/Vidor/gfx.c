/*
 * gfx.c
 *
 *  Created on: Apr 11, 2018
 *      Author: max
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <alt_types.h>
#include <system.h>

#include "mb.h"

#define FB_BASE (alt_u16*)(SDRAM_ARBITER_BASE + \
		                   SDRAM_ARBITER_FB_OFFSET*sizeof(short))
#define FB_WIDTH  640
#define FB_HEIGHT 480
#define CAM_BASE (alt_u16*)(SDRAM_ARBITER_BASE)

#define _swap_int16_t(a,b) {int16_t t=a; a=b; b=t;}

typedef struct { // Data stored PER GLYPH
	alt_u16  bitmapOffset;     // Pointer into GFXfont->bitmap
	alt_u8   width, height;    // Bitmap dimensions in pixels
	alt_u8   xAdvance;         // Distance to advance cursor (x axis)
	alt_8    xOffset, yOffset; // Dist from cursor pos to UL corner
} GFXglyph;

typedef struct { // Data stored for FONT AS A WHOLE:
	alt_u8   *bitmap;      // Glyph bitmaps, concatenated
	GFXglyph *glyph;       // Glyph array
	alt_u8    first, last; // ASCII extents
	alt_u8    yAdvance;    // Newline distance (y axis)
} GFXfont;

typedef struct { // Data stored PER GLYPH
	alt_u32  type;
	alt_u16  width;
	alt_u16  height;    // Bitmap dimensions in pixels
	alt_u32  size;
	alt_u16 *bmp;       // pointer to bitmap
} GFXbmp;

alt_u32 writePixel(alt_u16 x, alt_u16 y, alt_u16 color);
alt_u32 writeLine (alt_u16 x0, alt_u16 y0, alt_u16 x1, alt_u16 y1, alt_u16 color);
alt_u32 drawRect  (alt_u16 x, alt_u16 y, alt_u16 w, alt_u16 h, alt_u16 color);
alt_u32 fillRect  (alt_u16 x, alt_u16 y, alt_u16 w, alt_u16 h, alt_u16 color);
alt_u32 drawCircle(alt_u16 x0, alt_u16 y0, alt_u16 r, alt_u16 color);
alt_u32 fillCircle(alt_u16 x0, alt_u16 y0, alt_u16 r, alt_u16 color);
alt_u32 drawChar  (alt_u16 x, alt_u16 y, alt_u16 color, alt_u8 size, alt_u8 c);
alt_u32 drawTxt   (alt_u16 x, alt_u16 y, alt_u16 color, alt_u8* txt);
alt_u32 drawBmp   (GFXbmp* bmp, alt_u16 x, alt_u16 y, alt_u16 color);


typedef void (*pfv3)(alt_u32, alt_u32, alt_u32);
typedef void (*pfv4)(alt_u32, alt_u32, alt_u32, alt_u32);
typedef void (*pfv5)(alt_u32, alt_u32, alt_u32, alt_u32, alt_u32);
typedef int  (*pfi4)(alt_u32, alt_u32, alt_u32, alt_u32);
typedef int  (*pfi5)(alt_u32, alt_u32, alt_u32, alt_u32, alt_u32);

typedef struct {
	alt_u32 fnc;
	alt_u8  ret_prm;
}sFncTbl, *psFncTbl;

sFncTbl fncTbl[] = {
	{(alt_u32)writePixel, 0x03},
	{(alt_u32)writeLine , 0x05},
	{(alt_u32)drawRect  , 0x05},
	{(alt_u32)fillRect  , 0x05},
	{(alt_u32)drawCircle, 0x04},
	{(alt_u32)fillCircle, 0x04},
	{(alt_u32)drawChar  , 0x15},
	{(alt_u32)drawTxt   , 0x14},
};

#include "Fonts/FreeMono12pt7b.h"
GFXfont *gfxFont = (GFXfont*)&FreeMono12pt7b;


alt_u16 arduino_bmp[] = {
		0x0000, 0x0000, 0x0FC0, 0x0000, 0x0000, 0x0000, 0x0000, 0x03F0,
		0x0000, 0x0000, 0x0000, 0x0003, 0xFFFF, 0xC000, 0x0000, 0x0000,
		0x0003, 0xFFFF, 0xE000, 0x0000, 0x0000, 0x003F, 0xFFFF, 0xF800,
		0x0000, 0x0000, 0x001F, 0xFFFF, 0xFC00, 0x0000, 0x0000, 0x01FF,
		0xFFFF, 0xFF00, 0x0000, 0x0000, 0x00FF, 0xFFFF, 0xFF80, 0x03A2,
		0x0000, 0x07FF, 0xFFFF, 0xFFE0, 0x0000, 0x0000, 0x07FF, 0xFFFF,
		0xFFE0, 0x0136, 0x0000, 0x1FFF, 0xFFFF, 0xFFF8, 0x0000, 0x0000,
		0x0FFF, 0xFFFF, 0xFFF8, 0x012A, 0x0000, 0x7FFF, 0xFFFF, 0xFFFC,
		0x0000, 0x0000, 0x3FFF, 0xFFFF, 0xFFFE, 0x0122, 0x0000, 0xFFFF,
		0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x8000,
		0x0001, 0xFFFF, 0xFFFF, 0xFFFF, 0x8000, 0x0001, 0xFFFF, 0xFFFF,
		0xFFFF, 0x8000, 0x0003, 0xFFFF, 0xFFFF, 0xFFFF, 0xC000, 0x0003,
		0xFFFF, 0xFFFF, 0xFFFF, 0xE000, 0x000F, 0xFFFF, 0xFFFF, 0xFFFF,
		0xE000, 0x0007, 0xFFFF, 0xFFFF, 0xFFFF, 0xF000, 0x001F, 0xFFFF,
		0xFFFF, 0xFFFF, 0xF800, 0x000F, 0xFFFF, 0xFFFF, 0xFFFF, 0xF800,
		0x003F, 0xFFFF, 0xFFFF, 0xFFFF, 0xFC00, 0x003F, 0xFFFF, 0xFFFF,
		0xFFFF, 0xFC00, 0x003F, 0xFFFF, 0xC007, 0xFFFF, 0xFE00, 0x007F,
		0xFFFF, 0xE003, 0xFFFF, 0xFE00, 0x007F, 0xFFFC, 0x0000, 0x3FFF,
		0xFF00, 0x00FF, 0xFFFE, 0x0000, 0x3FFF, 0xFE00, 0x01FF, 0xFFF0,
		0x0000, 0x0FFF, 0xFF80, 0x01FF, 0xFFF0, 0x0000, 0x07FF, 0xFF80,
		0x01FF, 0xFFE0, 0x0000, 0x07FF, 0xFFC0, 0x01FF, 0xFFE0, 0x0000,
		0x03FF, 0xFF80, 0x03FF, 0xFF80, 0x0000, 0x01FF, 0xFFC0, 0x03FF,
		0xFF80, 0x0000, 0x01FF, 0xFFC0, 0x03FF, 0xFE00, 0x0000, 0x007F,
		0xFFE0, 0x07FF, 0xFE00, 0x0000, 0x007F, 0xFFC0, 0x07FF, 0xFC00,
		0x0000, 0x003F, 0xFFF0, 0x0FFF, 0xFC00, 0x0000, 0x003F, 0xFFE0,
		0x07FF, 0xF800, 0x0000, 0x001F, 0xFFF8, 0x1FFF, 0xF800, 0x0000,
		0x000F, 0xFFF0, 0x0FFF, 0xF000, 0x0000, 0x000F, 0xFFFC, 0x1FFF,
		0xF000, 0x0000, 0x000F, 0xFFF0, 0x0FFF, 0xE000, 0x0000, 0x0007,
		0xFFFC, 0x3FFF, 0xE000, 0x0000, 0x0007, 0xFFF8, 0x1FFF, 0xC000,
		0x0000, 0x0003, 0xFFFE, 0x3FFF, 0xC000, 0x0000, 0x0003, 0xFFF8,
		0x1FFF, 0xC000, 0x0000, 0x0001, 0xFFFE, 0x7FFF, 0x8000, 0x0000,
		0x0003, 0xFFF8, 0x1FFF, 0x8000, 0x0000, 0x0000, 0xFFFF, 0xFFFF,
		0x0000, 0x0000, 0x0001, 0xFFFC, 0x3FFF, 0x0000, 0x0000, 0x0000,
		0x7FFF, 0xFFFE, 0x0000, 0x0FE0, 0x0000, 0xFFFC, 0x3FFE, 0x0000,
		0x0000, 0x0000, 0x3FFF, 0xFFFC, 0x0000, 0x0FE0, 0x0000, 0x7FFC,
		0x3FFE, 0x0000, 0x0000, 0x0000, 0x1FFF, 0xFFF8, 0x0000, 0x0FE0,
		0x0000, 0x7FFC, 0x7FFE, 0x0000, 0x0000, 0x0000, 0x1FFF, 0xFFF8,
		0x0000, 0x0FE0, 0x0000, 0x3FFE, 0x7FFC, 0x0000, 0x0000, 0x0000,
		0x0FFF, 0xFFF0, 0x0000, 0x0FE0, 0x0000, 0x3FFE, 0x7FFC, 0x0000,
		0x0000, 0x0000, 0x07FF, 0xFFF0, 0x0000, 0x0FE0, 0x0000, 0x3FFE,
		0x7FFC, 0x0000, 0x0000, 0x0000, 0x07FF, 0xFFE0, 0x0000, 0x0FE0,
		0x0000, 0x3FFE, 0x7FFC, 0x000F, 0xFFFF, 0xF000, 0x03FF, 0xFFC0,
		0x000F, 0xFFFF, 0xC000, 0x1FFE, 0x7FF8, 0x000F, 0xFFFF, 0xF000,
		0x01FF, 0xFFC0, 0x000F, 0xFFFF, 0xC000, 0x1FFE, 0x7FF8, 0x000F,
		0xFFFF, 0xF000, 0x01FF, 0xFF80, 0x000F, 0xFFFF, 0xC000, 0x1FFE,
		0x7FF8, 0x000F, 0xFFFF, 0xF000, 0x00FF, 0xFF00, 0x000F, 0xFFFF,
		0xC000, 0x1FFE, 0x7FF8, 0x000F, 0xFFFF, 0xF000, 0x00FF, 0xFF00,
		0x000F, 0xFFFF, 0xC000, 0x1FFE, 0x7FF8, 0x000F, 0xFFFF, 0xF000,
		0x01FF, 0xFF80, 0x000F, 0xFFFF, 0xC000, 0x1FFE, 0x7FF8, 0x000F,
		0xFFFF, 0xF000, 0x01FF, 0xFF80, 0x000F, 0xFFFF, 0xC000, 0x1FFE,
		0x7FF8, 0x0000, 0x0000, 0x0000, 0x03FF, 0xFFC0, 0x0000, 0x0FE0,
		0x0000, 0x1FFE, 0x7FF8, 0x0000, 0x0000, 0x0000, 0x03FF, 0xFFC0,
		0x0000, 0x0FE0, 0x0000, 0x1FFE, 0x7FFC, 0x0000, 0x0000, 0x0000,
		0x07FF, 0xFFE0, 0x0000, 0x0FE0, 0x0000, 0x3FFE, 0x7FFC, 0x0000,
		0x0000, 0x0000, 0x0FFF, 0xFFF0, 0x0000, 0x0FE0, 0x0000, 0x3FFE,
		0x7FFC, 0x0000, 0x0000, 0x0000, 0x0FFF, 0xFFF0, 0x0000, 0x0FE0,
		0x0000, 0x3FFE, 0x7FFE, 0x0000, 0x0000, 0x0000, 0x1FFF, 0xFFF8,
		0x0000, 0x0FE0, 0x0000, 0x3FFE, 0x3FFE, 0x0000, 0x0000, 0x0000,
		0x3FFF, 0xFFFC, 0x0000, 0x0FE0, 0x0000, 0x7FFC, 0x3FFE, 0x0000,
		0x0000, 0x0000, 0x3FFF, 0xFFFC, 0x0000, 0x0FE0, 0x0000, 0x7FFC,
		0x3FFF, 0x0000, 0x0000, 0x0000, 0x7FFF, 0xFFFE, 0x0000, 0x0000,
		0x0000, 0xFFFC, 0x3FFF, 0x8000, 0x0000, 0x0000, 0xFFFF, 0xFFFF,
		0x0000, 0x0000, 0x0001, 0xFFFC, 0x1FFF, 0x8000, 0x0000, 0x0001,
		0xFFFE, 0x7FFF, 0x8000, 0x0000, 0x0001, 0xFFF8, 0x1FFF, 0xC000,
		0x0000, 0x0003, 0xFFFC, 0x3FFF, 0xC000, 0x0000, 0x0003, 0xFFF8,
		0x0FFF, 0xE000, 0x0000, 0x0007, 0xFFFC, 0x3FFF, 0xE000, 0x0000,
		0x0007, 0xFFF0, 0x0FFF, 0xF000, 0x0000, 0x0007, 0xFFF8, 0x1FFF,
		0xF000, 0x0000, 0x000F, 0xFFF0, 0x0FFF, 0xF000, 0x0000, 0x000F,
		0xFFF8, 0x1FFF, 0xF000, 0x0000, 0x000F, 0xFFF0, 0x07FF, 0xF800,
		0x0000, 0x001F, 0xFFF0, 0x0FFF, 0xF800, 0x0000, 0x001F, 0xFFE0,
		0x07FF, 0xFC00, 0x0000, 0x003F, 0xFFE0, 0x07FF, 0xFC00, 0x0000,
		0x003F, 0xFFE0, 0x03FF, 0xFF00, 0x0000, 0x007F, 0xFFE0, 0x03FF,
		0xFF00, 0x0000, 0x007F, 0xFFC0, 0x01FF, 0xFFC0, 0x0000, 0x01FF,
		0xFFC0, 0x03FF, 0xFFC0, 0x0000, 0x03FF, 0xFF80, 0x01FF, 0xFFF0,
		0x0000, 0x07FF, 0xFF80, 0x01FF, 0xFFE0, 0x0000, 0x07FF, 0xFF80,
		0x007F, 0xFFFC, 0x0000, 0x1FFF, 0xFF00, 0x007F, 0xFFFC, 0x0000,
		0x3FFF, 0xFE00, 0x003F, 0xFFFF, 0xC001, 0xFFFF, 0xFE00, 0x007F,
		0xFFFF, 0x8003, 0xFFFF, 0xFE00, 0x003F, 0xFFFF, 0xFC1F, 0xFFFF,
		0xFC00, 0x003F, 0xFFFF, 0xF83F, 0xFFFF, 0xFC00, 0x001F, 0xFFFF,
		0xFFFF, 0xFFFF, 0xF800, 0x001F, 0xFFFF, 0xFFFF, 0xFFFF, 0xF800,
		0x000F, 0xFFFF, 0xFFFF, 0xFFFF, 0xF000, 0x000F, 0xFFFF, 0xFFFF,
		0xFFFF, 0xF000, 0x0007, 0xFFFF, 0xFFFF, 0xFFFF, 0xE000, 0x0007,
		0xFFFF, 0xFFFF, 0xFFFF, 0xE000, 0x0003, 0xFFFF, 0xFFFF, 0xFFFF,
		0xC000, 0x0003, 0xFFFF, 0xFFFF, 0xFFFF, 0xC000, 0x0000, 0xFFFF,
		0xFFFF, 0xFFFF, 0x8000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x8000,
		0x0000, 0x7FFF, 0xFFFF, 0xFFFE, 0x0000, 0x0000, 0x7FFF, 0xFFFF,
		0xFFFE, 0x0000, 0x0000, 0x1FFF, 0xFFFF, 0xFFF8, 0x0000, 0x0000,
		0x1FFF, 0xFFFF, 0xFFF8, 0x0000, 0x0000, 0x0FFF, 0xFFFF, 0xFFF0,
		0x0000, 0x0000, 0x0FFF, 0xFFFF, 0xFFF0, 0x0000, 0x0000, 0x03FF,
		0xFFFF, 0xFFC0, 0x0000, 0x0000, 0x03FF, 0xFFFF, 0xFFC0, 0x0000,
		0x0000, 0x007F, 0xFFFF, 0xFF00, 0x0000, 0x0000, 0x00FF, 0xFFFF,
		0xFE00, 0x0000, 0x0000, 0x000F, 0xFFFF, 0xF800, 0x0000, 0x0000,
		0x001F, 0xFFFF, 0xF000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x8000,
		0x0000, 0x0000, 0x0001, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000, 0x0000, 0x0000, 0x007F, 0x803F, 0xFE01, 0xFFF8,
		0x03F0, 0x0FE3, 0xFFFF, 0x0FE0, 0x3E01, 0xFFC0, 0x00FF, 0x803F,
		0xFFC1, 0xFFFE, 0x03F0, 0x0FE3, 0xFFFF, 0x0FF0, 0x3E03, 0xFFE0,
		0x00FF, 0x803F, 0xFFE1, 0xFFFF, 0x83F0, 0x0FE3, 0xFFFF, 0x0FF0,
		0x3E0F, 0xFFF0, 0x01FF, 0xC03F, 0xFFE1, 0xFFFF, 0xC3F0, 0x0FE3,
		0xFFFF, 0x0FF0, 0x3E0F, 0xFFF8, 0x01FF, 0xC03F, 0xFFF1, 0xFFFF,
		0xE3F0, 0x0FE3, 0xFFFF, 0x0FF8, 0x3E1F, 0xFFF8, 0x01FF, 0xC03F,
		0x0FF1, 0xFC3F, 0xE3F0, 0x0FE0, 0x0FC0, 0x0FF8, 0x3E1F, 0xC3FC,
		0x01FF, 0xE03F, 0x07F1, 0xFC0F, 0xF3F0, 0x0FE0, 0x0FC0, 0x0FFC,
		0x3E3F, 0x81FC, 0x03FF, 0xE03F, 0x03F1, 0xFC07, 0xF3F0, 0x0FE0,
		0x0FC0, 0x0FFC, 0x3E3F, 0x80FE, 0x03F7, 0xE03F, 0x03F1, 0xFC07,
		0xF3F0, 0x0FE0, 0x0FC0, 0x0FFE, 0x3E3F, 0x007E, 0x03F7, 0xE03F,
		0x07F1, 0xFC03, 0xF3F0, 0x0FE0, 0x0FC0, 0x0FFE, 0x3E3E, 0x007E,
		0x07E7, 0xF03F, 0x0FF1, 0xFC03, 0xF3F0, 0x0FE0, 0x0FC0, 0x0FFF,
		0x3E7E, 0x007E, 0x07E7, 0xF03F, 0xFFE1, 0xFC03, 0xF3F0, 0x0FE0,
		0x0FC0, 0x0FFF, 0x3E7E, 0x007E, 0x07E3, 0xF03F, 0xFFC1, 0xFC03,
		0xF3F0, 0x0FE0, 0x0FC0, 0x0FBF, 0xBE7E, 0x007E, 0x07E3, 0xF83F,
		0xFF81, 0xFC03, 0xF3F0, 0x0FE0, 0x0FC0, 0x0F9F, 0xBE7E, 0x007E,
		0x0FC3, 0xF83F, 0xFF01, 0xFC03, 0xF3F0, 0x0FE0, 0x0FC0, 0x0F9F,
		0xFE7E, 0x007E, 0x0FC1, 0xF83F, 0xFF81, 0xFC03, 0xF3F0, 0x0FE0,
		0x0FC0, 0x0F8F, 0xFE7E, 0x007E, 0x0FFF, 0xF83F, 0x1FC1, 0xFC03,
		0xF3F0, 0x0FE0, 0x0FC0, 0x0F8F, 0xFE3F, 0x007E, 0x1FFF, 0xFC3F,
		0x1FC1, 0xFC07, 0xF3F0, 0x0FE0, 0x0FC0, 0x0F87, 0xFE3F, 0x007E,
		0x1FFF, 0xFC3F, 0x0FE1, 0xFC07, 0xF3F0, 0x0FC0, 0x0FC0, 0x0F87,
		0xFE3F, 0x80FC, 0x1FFF, 0xFC3F, 0x0FE1, 0xFC0F, 0xF3F8, 0x0FC0,
		0x0FC0, 0x0F87, 0xFE3F, 0x80FC, 0x1FFF, 0xFE3F, 0x07E1, 0xFC1F,
		0xE3F8, 0x0FC0, 0x0FC0, 0x0F83, 0xFE3F, 0xC1FC, 0x3F80, 0xFE3F,
		0x07F1, 0xFFFF, 0xC1FC, 0x1FC3, 0xFFFF, 0x0F83, 0xFE1F, 0xFFF8,
		0x3F00, 0x7E3F, 0x07F1, 0xFFFF, 0xC1FF, 0xFF83, 0xFFFF, 0x0F81,
		0xFE1F, 0xFFF8, 0x3E00, 0x7E3F, 0x03F9, 0xFFFF, 0x80FF, 0xFF83,
		0xFFFF, 0x0F81, 0xFE0F, 0xFFF0, 0x7E00, 0x3F3F, 0x03F9, 0xFFFE,
		0x007F, 0xFE03, 0xFFFF, 0x0F80, 0xFE07, 0xFFE0, 0x7C00, 0x3F3F,
		0x01FD, 0xFFF0, 0x001F, 0xFC03, 0xFFFF, 0x0F80, 0x7E01, 0xFF80,
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
		0x0000, 0x0000,
};
GFXbmp arduinoLogo = {0, 160, 110, sizeof(arduino_bmp)/sizeof(alt_u16), arduino_bmp};



/**
 */
void gfxInit(int devs)
{
	int x;
	int i;
	char txt[] = {"Hello World"};

    memset(CAM_BASE, 0, FB_WIDTH*FB_HEIGHT*2);
    memset(FB_BASE, 0, FB_WIDTH*FB_HEIGHT*2);

    drawBmp(&arduinoLogo, 640-160, 480-110, 33396);
}

/**
 *
 */
void gfxCmd(void)
{
	alt_u32 volatile *rpc = (alt_u32*)DPRAM_BASE;
	int ret = -1;
	int idx = MB_CMD(rpc[0]);

	if (idx >= sizeof(fncTbl)/sizeof(sFncTbl)) {
		rpc[1] = -1;
		return;
	}

	switch (fncTbl[idx].ret_prm) {
	case 0x03:
		((pfv3)fncTbl[idx].fnc)(rpc[1], rpc[2], rpc[3]);
		break;
	case 0x04:
		((pfv4)fncTbl[idx].fnc)(rpc[1], rpc[2], rpc[3], rpc[4]);
		break;
	case 0x05:
		((pfv5)fncTbl[idx].fnc)(rpc[1], rpc[2], rpc[3], rpc[4], rpc[5]);
		break;
	case 0x14:
//		ret = ((pfi4)fncTbl[idx].fnc)(rpc[1], rpc[2], rpc[3], (alt_u8*)&rpc[4]);
		ret = ((pfi4)fncTbl[idx].fnc)(rpc[1], rpc[2], rpc[3], (alt_u32)&rpc[4]);
		break;
	case 0x15:
		ret = ((pfi5)fncTbl[idx].fnc)(rpc[1], rpc[2], rpc[3], rpc[4], rpc[5]);
		break;
	}
	rpc[1] = ret;
}

/**
 * Draw a Point of color at x, y
 */
alt_u32 writePixel(alt_u16 x, alt_u16 y, uint16_t color)
{
	alt_u16 *p;

	p = FB_BASE + (x + y*FB_WIDTH);
	*p = color;
	return 0;
}

/**
 */
alt_u32 writeHLine(alt_u16 x, alt_u16 y, alt_u16 l, uint16_t color)
{
	alt_u32 i;

	for(i=x; i<x+l; i++){
		writePixel(i, y, color);
	}
	return 0;
}

/**
 */
alt_u32 writeVLine(alt_u16 x, alt_u16 y, alt_u16 l, alt_u16 color)
{
	alt_u32 i;

	for(i=y; i<y+l; i++){
		writePixel(x, i, color);
	}
	return 0;
}

/**
 *
 */
alt_u32 writeLine(alt_u16 x0, alt_u16 y0, alt_u16 x1, alt_u16 y1, alt_u16 color)
{
	alt_16 steep = abs(y1 - y0) > abs(x1 - x0);
	alt_16 dx, dy;
	alt_16 err;
	alt_16 ystep;

	if (steep) {
		_swap_int16_t(x0, y0);
		_swap_int16_t(x1, y1);
	}

	if (x0 > x1) {
		_swap_int16_t(x0, x1);
		_swap_int16_t(y0, y1);
	}

	dx = x1 - x0;
	dy = abs(y1 - y0);
	err = dx / 2;

	if(y0<y1){
		ystep = 1;
	} else {
		ystep = -1;
	}

	for(; x0<=x1; x0++){
		if(steep){
			writePixel(y0, x0, color);
		}else{
			writePixel(x0, y0, color);
		}
		err -= dy;
		if(err<0){
			y0 += ystep;
			err += dx;
		}
	}
	return 0;
}

/**
 * Draw a rectangle
 */
alt_u32 drawRect(alt_u16 x, alt_u16 y, alt_u16 w, alt_u16 h, alt_u16 color)
{
	writeHLine(x, y, w, color);
	writeHLine(x, y+h-1, w, color);
	writeVLine(x, y, h, color);
	writeVLine(x+w-1, y, h, color);
	return 0;
}
/**
 */
alt_u32 fillRect(alt_u16 x, alt_u16 y, alt_u16 w, alt_u16 h, alt_u16 color)
{
	alt_u32 i;
	for (i=x; i<x+w; i++) {
		writeVLine(i, y, h, color);
	}
	return 0;
}

/**
 *
 */
alt_u32 drawCircleHelper(alt_16 x0, alt_16 y0, alt_16 r, alt_u8 cornername, alt_u16 color)
{
	alt_16 f     = 1 - r;
	alt_16 ddF_x = 1;
	alt_16 ddF_y = -2 * r;
	alt_16 x     = 0;
	alt_16 y     = r;

    while (x<y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f     += ddF_y;
        }
        x++;
        ddF_x += 2;
        f     += ddF_x;
        if (cornername & 0x4) {
            writePixel(x0 + x, y0 + y, color);
            writePixel(x0 + y, y0 + x, color);
        }
        if (cornername & 0x2) {
            writePixel(x0 + x, y0 - y, color);
            writePixel(x0 + y, y0 - x, color);
        }
        if (cornername & 0x8) {
            writePixel(x0 - y, y0 + x, color);
            writePixel(x0 - x, y0 + y, color);
        }
        if (cornername & 0x1) {
            writePixel(x0 - y, y0 - x, color);
            writePixel(x0 - x, y0 - y, color);
        }
    }
	return 0;
}

/**
 * Draw a circle outline
 */
alt_u32 drawCircle(alt_u16 x0, alt_u16 y0, alt_u16 r, alt_u16 color)
{
	alt_16 f     =  1 - r;
	alt_16 ddF_x =  1;
	alt_16 ddF_y = -2 * r;
	alt_16 x     =  0;
	alt_16 y     =  r;

	writePixel(x0  , y0+r, color);
	writePixel(x0  , y0-r, color);
	writePixel(x0+r, y0  , color);
	writePixel(x0-r, y0  , color);

	while(x<y){
		if(f>=0){
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		writePixel(x0 + x, y0 + y, color);
		writePixel(x0 - x, y0 + y, color);
		writePixel(x0 + x, y0 - y, color);
		writePixel(x0 - x, y0 - y, color);
		writePixel(x0 + y, y0 + x, color);
		writePixel(x0 - y, y0 + x, color);
		writePixel(x0 + y, y0 - x, color);
		writePixel(x0 - y, y0 - x, color);
	}
	return 0;
}

/**
 * Used to do circles and roundrects
 *
 */
alt_u32 fillCircleHelper(alt_u16 x0, alt_u16 y0, alt_u16 r, uint8_t cornername, alt_u16 delta, alt_u16 color)
{
	alt_16 f     =  1 - r;
	alt_16 ddF_x =  1;
	alt_16 ddF_y = -2 * r;
	alt_16 x     =  0;
	alt_16 y     =  r;

	while (x<y) {
		if (f >= 0) {
			y--;
			ddF_y += 2;
			f     += ddF_y;
		}
		x++;
		ddF_x += 2;
		f     += ddF_x;

		if (cornername & 0x1) {
			writeVLine(x0+x, y0-y, 2*y+1+delta, color);
			writeVLine(x0+y, y0-x, 2*x+1+delta, color);
		}
		if (cornername & 0x2) {
			writeVLine(x0-x, y0-y, 2*y+1+delta, color);
			writeVLine(x0-y, y0-x, 2*x+1+delta, color);
		}
	}
	return 0;
}

/**
 */
alt_u32 fillCircle(alt_u16 x0, alt_u16 y0, alt_u16 r, alt_u16 color)
{
	writeVLine(x0, y0-r, 2*r+1, color);
	fillCircleHelper(x0, y0, r, 3, 0, color);
	return 0;
}

/**
 * Draw a rounded rectangle
 */
alt_u32 drawRoundRect(int16_t x, int16_t y, int16_t w,
        int16_t h, int16_t r, uint16_t color) {
    // smarter version
    writeHLine(x+r  , y    , w-2*r, color); // Top
    writeHLine(x+r  , y+h-1, w-2*r, color); // Bottom
    writeVLine(x    , y+r  , h-2*r, color); // Left
    writeVLine(x+w-1, y+r  , h-2*r, color); // Right
    // draw four corners
    drawCircleHelper(x+r    , y+r    , r, 1, color);
    drawCircleHelper(x+w-r-1, y+r    , r, 2, color);
    drawCircleHelper(x+w-r-1, y+h-r-1, r, 4, color);
    drawCircleHelper(x+r    , y+h-r-1, r, 8, color);
	return 0;
}

/**
 * Fill a rounded rectangle
 */
alt_u32 fillRoundRect(int16_t x, int16_t y, int16_t w,
        int16_t h, int16_t r, uint16_t color) {
    // smarter version
    fillRect(x+r, y, w-2*r, h, color);

    // draw four corners
    fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
    fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
	return 0;
}

// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------

/**
 * Draw a character
 */
alt_u32 drawChar(alt_u16 x, alt_u16 y, alt_u16 color, uint8_t size, alt_u8 c)
{
	// Custom font

	// Character is assumed previously filtered by write() to eliminate
	// newlines, returns, non-printable characters, etc.  Calling
	// drawChar() directly with 'bad' characters of font may cause mayhem!

	c -= gfxFont->first;
	GFXglyph *glyph  = &(gfxFont->glyph[c]);
	alt_u8  *bitmap = gfxFont->bitmap;
	alt_u16  bo = glyph->bitmapOffset;
	alt_u8   w  = glyph->width;
	alt_u8   h  = glyph->height;
	alt_8    xo = glyph->xOffset;
	alt_8    yo = glyph->yOffset;
	alt_u8   xx, yy, bits = 0, bit = 0;
	alt_16   xo16 = 0, yo16 = 0;

	if(size > 1){
		xo16 = xo;
		yo16 = yo;
	}

	// Todo: Add character clipping here

	// NOTE: THERE IS NO 'BACKGROUND' COLOR OPTION ON CUSTOM FONTS.
	// THIS IS ON PURPOSE AND BY DESIGN.  The background color feature
	// has typically been used with the 'classic' font to overwrite old
	// screen contents with new data.  This ONLY works because the
	// characters are a uniform size; it's not a sensible thing to do with
	// proportionally-spaced fonts with glyphs of varying sizes (and that
	// may overlap).  To replace previously-drawn text when using a custom
	// font, use the getTextBounds() function to determine the smallest
	// rectangle encompassing a string, erase the area with fillRect(),
	// then draw new text.  This WILL infortunately 'blink' the text, but
	// is unavoidable.  Drawing 'background' pixels will NOT fix this,
	// only creates a new set of problems.  Have an idea to work around
	// this (a canvas object type for MCUs that can afford the RAM and
	// displays supporting setAddrWindow() and pushColors()), but haven't
	// implemented this yet.


	for(yy=0; yy<h; yy++) {
		for(xx=0; xx<w; xx++) {
			if(!(bit++ & 7)) {
				bits = bitmap[bo++];
			}
			if(bits & 0x80) {
				if(size == 1) {
					writePixel(x+xo+xx, y+yo+yy, color);
				} else {
					fillRect(x+(xo16+xx)*size, y+(yo16+yy)*size, size, size, color);
				}
			}
			bits <<= 1;
		}
	}
	return glyph->xAdvance * size;
}

/**
 *
 */
alt_u32 drawTxt(alt_u16 x, alt_u16 y, alt_u16 color, alt_u8* txt)
{
	int size;
	int i;

	size = 0;
	for(i=0; txt[i]; i++){
		size += drawChar(x+size, y, color, 1, txt[i]);
	}

	return size;
}

/**
 *
 */
alt_u32 drawBmp(GFXbmp* bmp, alt_u16 x, alt_u16 y, alt_u16 color)
{
	int xpos = x;
	int i;
	int j;
	alt_u16 tmp;

	for(i=0; i<bmp->size; i++) {
		tmp = bmp->bmp[i];
		for(j=0; j<16; j++){
			if(tmp & 0x8000) {
				writePixel(xpos, y, color);
			}
			tmp <<= 1;
			xpos++;
			if(xpos == x+bmp->width) {
				xpos = x;
				y++;
			}
		}
	}

	return 0;
}
